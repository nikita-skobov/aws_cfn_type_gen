

/// Creates or updates the specified rule. Rules are enabled by default, or based on value of    the state. You can disable a rule using DisableRule.
///
/// A single rule watches for events from a single event bus. Events generated by AWS services    go to your account's default event bus. Events generated by SaaS partner services or    applications go to the matching partner event bus. If you have custom applications or    services, you can specify whether their events go to your default event bus or a custom event    bus that you have created. For more information, see CreateEventBus.
///
/// If you are updating an existing rule, the rule is replaced with what you specify in this     PutRule command. If you omit arguments in PutRule, the old values    for those arguments are not kept. Instead, they are replaced with null values.
///
/// When you create or update a rule, incoming events might not immediately start matching to    new or updated rules. Allow a short period of time for changes to take effect.
///
/// A rule must contain at least an EventPattern or ScheduleExpression. Rules with    EventPatterns are triggered when a matching event is observed. Rules with ScheduleExpressions    self-trigger based on the given schedule. A rule can have both an EventPattern and a    ScheduleExpression, in which case the rule triggers on matching events as well as on a    schedule.
///
/// Most services in AWS treat : or / as the same character in Amazon Resource Names (ARNs).    However, EventBridge uses an exact match in event patterns and rules. Be sure to use the    correct ARN characters when creating event patterns so that they match the ARN syntax in the    event you want to match.
///
/// In EventBridge, it is possible to create rules that lead to infinite loops, where a rule    is fired repeatedly. For example, a rule might detect that ACLs have changed on an S3 bucket,    and trigger software to change them to the desired state. If the rule is not written    carefully, the subsequent change to the ACLs fires the rule again, creating an infinite    loop.
///
/// To prevent this, write the rules so that the triggered actions do not re-fire the same    rule. For example, your rule could fire only if ACLs are found to be in a bad state, instead    of after any change.
///
/// An infinite loop can quickly cause higher than expected charges. We recommend that you use    budgeting, which alerts you when charges exceed your specified limit. For more information,    see Managing Your Costs with     Budgets.
#[derive(Clone, Debug, Default, serde::Serialize)]
pub struct CfnRule {


    /// 
    /// The description of the rule.
    /// 
    /// Required: No
    ///
    /// Type: String
    ///
    /// Maximum: 512
    ///
    /// Update requires: No interruption
    #[serde(rename = "Description")]
    pub description: Option<String>,


    /// 
    /// The name or ARN of the event bus associated with the rule. If you omit this, the default    event bus is used.
    /// 
    /// Required: No
    ///
    /// Type: String
    ///
    /// Minimum: 1
    ///
    /// Maximum: 256
    ///
    /// Pattern: [/\.\-_A-Za-z0-9]+
    ///
    /// Update requires: Replacement
    #[serde(rename = "EventBusName")]
    pub event_bus_name: Option<String>,


    /// 
    /// The event pattern of the rule. For more information, see Events and Event    Patterns in the Amazon EventBridge User Guide.
    /// 
    /// Required: Conditional
    ///
    /// Type: Json
    ///
    /// Maximum: 4096
    ///
    /// Update requires: No interruption
    #[serde(rename = "EventPattern")]
    pub event_pattern: Option<serde_json::Value>,


    /// 
    /// The name of the rule.
    /// 
    /// Required: No
    ///
    /// Type: String
    ///
    /// Minimum: 1
    ///
    /// Maximum: 64
    ///
    /// Pattern: [\.\-_A-Za-z0-9]+
    ///
    /// Update requires: Replacement
    #[serde(rename = "Name")]
    pub name: Option<String>,


    /// 
    /// The Amazon Resource Name (ARN) of the role that is used for target invocation.
    /// 
    /// If you're setting an event bus in another account as the target and that account granted    permission to your account through an organization instead of directly by the account ID, you    must specify a RoleArn with proper permissions in the Target    structure, instead of here in this parameter.
    /// 
    /// Required: No
    ///
    /// Type: String
    ///
    /// Minimum: 1
    ///
    /// Maximum: 1600
    ///
    /// Update requires: No interruption
    #[serde(rename = "RoleArn")]
    pub role_arn: Option<String>,


    /// 
    /// The scheduling expression. For example, "cron(0 20 * * ? *)", "rate(5 minutes)". For more information, see Creating an Amazon EventBridge rule that runs on a schedule.
    /// 
    /// Required: Conditional
    ///
    /// Type: String
    ///
    /// Maximum: 256
    ///
    /// Update requires: No interruption
    #[serde(rename = "ScheduleExpression")]
    pub schedule_expression: Option<String>,


    /// 
    /// The state of the rule.
    /// 
    /// Required: No
    ///
    /// Type: String
    ///
    /// Allowed values: DISABLED | ENABLED
    ///
    /// Update requires: No interruption
    #[serde(rename = "State")]
    pub state: Option<RuleStateEnum>,


    /// 
    /// Adds the specified targets to the specified rule, or updates the targets if they are    already associated with the rule.
    /// 
    /// Targets are the resources that are invoked when a rule is triggered.
    /// 
    /// The maximum number of entries per request is 10.
    /// 
    /// NoteEach rule can have up to five (5) targets associated with it at one time.
    /// 
    /// For a list of services you can configure as targets for events, see EventBridge targets    in the Amazon EventBridge User Guide.
    /// 
    /// Creating rules with built-in targets is supported only in the AWS Management Console. The    built-in targets are:
    /// 
    /// Amazon EBS CreateSnapshot API call                                Amazon EC2 RebootInstances API call                                Amazon EC2 StopInstances API call                                Amazon EC2 TerminateInstances API     call
    /// 
    /// For some target types, PutTargets provides target-specific parameters. If the    target is a Kinesis data stream, you can optionally specify which shard the event goes to by    using the KinesisParameters argument. To invoke a command on multiple EC2    instances with one rule, you can use the RunCommandParameters field.
    /// 
    /// To be able to make API calls against the resources that you own, Amazon EventBridge    needs the appropriate permissions:
    /// 
    /// For AWS Lambda and Amazon SNS     resources, EventBridge relies on resource-based policies.               For EC2 instances, Kinesis Data Streams,     AWS Step Functions state machines and API Gateway APIs, EventBridge relies on     IAM roles that you specify in the RoleARN argument in PutTargets.
    /// 
    /// For more information, see Authentication    and Access Control in the Amazon EventBridge User Guide.
    /// 
    /// If another AWS account is in the same region and has granted you permission (using     PutPermission), you can send events to that account. Set that account's event    bus as a target of the rules in your account. To send the matched events to the other account,    specify that account's event bus as the Arn value when you run     PutTargets. If your account sends events to another account, your account is    charged for each sent event. Each event sent to another account is charged as a custom event.    The account receiving the event is not charged. For more information, see Amazon EventBridge     Pricing.
    /// 
    /// Note        Input, InputPath, and InputTransformer are not     available with PutTarget if the target is an event bus of a different AWS     account.
    /// 
    /// If you are setting the event bus of another account as the target, and that account    granted permission to your account through an organization instead of directly by the account    ID, then you must specify a RoleArn with proper permissions in the     Target structure. For more information, see Sending and      Receiving Events Between AWS Accounts in the Amazon EventBridge User     Guide.
    /// 
    /// NoteIf you have an IAM role on a cross-account event bus target,    a PutTargets call without a role on the same target (same Id and Arn) will not remove the role.
    /// 
    /// For more information about enabling cross-account events, see PutPermission.
    /// 
    /// Input, InputPath, and     InputTransformer are mutually exclusive and optional    parameters of a target. When a rule is triggered due to a matched event:
    /// 
    /// If none of the following arguments are specified for a target, then the entire event      is passed to the target in JSON format (unless the target is Amazon EC2 Run Command or      Amazon ECS task, in which case nothing from the event is passed to the target).               If Input is specified in the form of valid JSON, then      the matched event is overridden with this constant.               If InputPath is specified in the form of JSONPath      (for example, $.detail), then only the part of the event specified in the      path is passed to the target (for example, only the detail part of the event is      passed).               If InputTransformer is specified, then one or more      specified JSONPaths are extracted from the event and used as values in a template that you      specify as the input to the target.
    /// 
    /// When you specify InputPath or InputTransformer, you must use    JSON dot notation, not bracket notation.
    /// 
    /// When you add targets to a rule and the associated rule triggers soon after, new or updated    targets might not be immediately invoked. Allow a short period of time for changes to take    effect.
    /// 
    /// This action can partially fail if too many requests are made at the same time. If that    happens, FailedEntryCount is non-zero in the response and each entry in     FailedEntries provides the ID of the failed target and the error code.
    /// 
    /// Required: No
    ///
    /// Type: List of Target
    ///
    /// Update requires: No interruption
    #[serde(rename = "Targets")]
    pub targets: Option<Vec<Target>>,

}


#[derive(Clone, Debug, serde::Serialize)]
pub enum RuleStateEnum {

    /// DISABLED
    #[serde(rename = "DISABLED")]
    Disabled,

    /// ENABLED
    #[serde(rename = "ENABLED")]
    Enabled,

}

impl Default for RuleStateEnum {
    fn default() -> Self {
        RuleStateEnum::Disabled
    }
}


impl cfn_resources::CfnResource for CfnRule {
    fn type_string() -> &'static str {
        "AWS::Events::Rule"
    }

    fn properties(self) -> serde_json::Value {
        serde_json::to_value(self).expect("Failed to serialize cloudformation resource properties")
    }

    fn validate(&self) -> Result<(), String> {

        if let Some(the_val) = &self.description {

        if the_val.len() > 512 as _ {
            return Err(format!("Max validation failed on field 'description'. {} is greater than 512", the_val.len()));
        }

        }
        
        if let Some(the_val) = &self.event_bus_name {

        if the_val.len() > 256 as _ {
            return Err(format!("Max validation failed on field 'event_bus_name'. {} is greater than 256", the_val.len()));
        }

        }
        
        if let Some(the_val) = &self.event_bus_name {

        if the_val.len() < 1 as _ {
            return Err(format!("Min validation failed on field 'event_bus_name'. {} is less than 1", the_val.len()));
        }

        }
        
        if let Some(the_val) = &self.name {

        if the_val.len() > 64 as _ {
            return Err(format!("Max validation failed on field 'name'. {} is greater than 64", the_val.len()));
        }

        }
        
        if let Some(the_val) = &self.name {

        if the_val.len() < 1 as _ {
            return Err(format!("Min validation failed on field 'name'. {} is less than 1", the_val.len()));
        }

        }
        
        if let Some(the_val) = &self.role_arn {

        if the_val.len() > 1600 as _ {
            return Err(format!("Max validation failed on field 'role_arn'. {} is greater than 1600", the_val.len()));
        }

        }
        
        if let Some(the_val) = &self.role_arn {

        if the_val.len() < 1 as _ {
            return Err(format!("Min validation failed on field 'role_arn'. {} is less than 1", the_val.len()));
        }

        }
        
        if let Some(the_val) = &self.schedule_expression {

        if the_val.len() > 256 as _ {
            return Err(format!("Max validation failed on field 'schedule_expression'. {} is greater than 256", the_val.len()));
        }

        }
        
        Ok(())
    }
}

/// This structure specifies the VPC subnets and security groups for the task, and whether a    public IP address is to be used. This structure is relevant only for ECS tasks that use the     awsvpc network mode.
#[derive(Clone, Debug, Default, serde::Serialize)]
pub struct AwsVpcConfiguration {


    /// 
    /// Specifies whether the task's elastic network interface receives a public IP address. You    can specify ENABLED only when LaunchType in     EcsParameters is set to FARGATE.
    /// 
    /// Required: No
    ///
    /// Type: String
    ///
    /// Allowed values: DISABLED | ENABLED
    ///
    /// Update requires: No interruption
    #[serde(rename = "AssignPublicIp")]
    pub assign_public_ip: Option<AwsVpcConfigurationAssignPublicIpEnum>,


    /// 
    /// Specifies the security groups associated with the task. These security groups must all be    in the same VPC. You can specify as many as five security groups. If you do not specify a    security group, the default security group for the VPC is used.
    /// 
    /// Required: No
    ///
    /// Type: List of String
    ///
    /// Update requires: No interruption
    #[serde(rename = "SecurityGroups")]
    pub security_groups: Option<Vec<String>>,


    /// 
    /// Specifies the subnets associated with the task. These subnets must all be in the same VPC.    You can specify as many as 16 subnets.
    /// 
    /// Required: Yes
    ///
    /// Type: List of String
    ///
    /// Update requires: No interruption
    #[serde(rename = "Subnets")]
    pub subnets: Vec<String>,

}


#[derive(Clone, Debug, serde::Serialize)]
pub enum AwsVpcConfigurationAssignPublicIpEnum {

    /// DISABLED
    #[serde(rename = "DISABLED")]
    Disabled,

    /// ENABLED
    #[serde(rename = "ENABLED")]
    Enabled,

}

impl Default for AwsVpcConfigurationAssignPublicIpEnum {
    fn default() -> Self {
        AwsVpcConfigurationAssignPublicIpEnum::Disabled
    }
}


impl cfn_resources::CfnResource for AwsVpcConfiguration {
    fn type_string() -> &'static str {
        "NOT_A_VALID_CFN_RESOURCE"
    }

    fn properties(self) -> serde_json::Value {
        serde_json::to_value(self).expect("Failed to serialize cloudformation resource properties")
    }

    fn validate(&self) -> Result<(), String> {

        Ok(())
    }
}

/// The array properties for the submitted job, such as the size of the array. The array size    can be between 2 and 10,000. If you specify array properties for a job, it becomes an array    job. This parameter is used only if the target is an AWS Batch job.
#[derive(Clone, Debug, Default, serde::Serialize)]
pub struct BatchArrayProperties {


    /// 
    /// The size of the array, if this is an array batch job. Valid values are integers between 2    and 10,000.
    /// 
    /// Required: No
    ///
    /// Type: Integer
    ///
    /// Update requires: No interruption
    #[serde(rename = "Size")]
    pub size: Option<i64>,

}



impl cfn_resources::CfnResource for BatchArrayProperties {
    fn type_string() -> &'static str {
        "NOT_A_VALID_CFN_RESOURCE"
    }

    fn properties(self) -> serde_json::Value {
        serde_json::to_value(self).expect("Failed to serialize cloudformation resource properties")
    }

    fn validate(&self) -> Result<(), String> {

        Ok(())
    }
}

/// The custom parameters to be used when the target is an AWS Batch job.
#[derive(Clone, Debug, Default, serde::Serialize)]
pub struct BatchParameters {


    /// 
    /// The array properties for the submitted job, such as the size of the array. The array size    can be between 2 and 10,000. If you specify array properties for a job, it becomes an array    job. This parameter is used only if the target is an AWS Batch job.
    /// 
    /// Required: No
    ///
    /// Type: BatchArrayProperties
    ///
    /// Update requires: No interruption
    #[serde(rename = "ArrayProperties")]
    pub array_properties: Option<BatchArrayProperties>,


    /// 
    /// The ARN or name of the job definition to use if the event target is an AWS Batch job. This    job definition must already exist.
    /// 
    /// Required: Yes
    ///
    /// Type: String
    ///
    /// Update requires: No interruption
    #[serde(rename = "JobDefinition")]
    pub job_definition: String,


    /// 
    /// The name to use for this execution of the job, if the target is an AWS Batch job.
    /// 
    /// Required: Yes
    ///
    /// Type: String
    ///
    /// Update requires: No interruption
    #[serde(rename = "JobName")]
    pub job_name: String,


    /// 
    /// The retry strategy to use for failed jobs, if the target is an AWS Batch job. The retry    strategy is the number of times to retry the failed job execution. Valid values are 1–10. When    you specify a retry strategy here, it overrides the retry strategy defined in the job    definition.
    /// 
    /// Required: No
    ///
    /// Type: BatchRetryStrategy
    ///
    /// Update requires: No interruption
    #[serde(rename = "RetryStrategy")]
    pub retry_strategy: Option<BatchRetryStrategy>,

}



impl cfn_resources::CfnResource for BatchParameters {
    fn type_string() -> &'static str {
        "NOT_A_VALID_CFN_RESOURCE"
    }

    fn properties(self) -> serde_json::Value {
        serde_json::to_value(self).expect("Failed to serialize cloudformation resource properties")
    }

    fn validate(&self) -> Result<(), String> {

        self.array_properties.as_ref().map_or(Ok(()), |val| val.validate())?;

        self.retry_strategy.as_ref().map_or(Ok(()), |val| val.validate())?;

        Ok(())
    }
}

/// The retry strategy to use for failed jobs, if the target is an AWS Batch job. If you    specify a retry strategy here, it overrides the retry strategy defined in the job    definition.
#[derive(Clone, Debug, Default, serde::Serialize)]
pub struct BatchRetryStrategy {


    /// 
    /// The number of times to attempt to retry, if the job fails. Valid values are 1–10.
    /// 
    /// Required: No
    ///
    /// Type: Integer
    ///
    /// Update requires: No interruption
    #[serde(rename = "Attempts")]
    pub attempts: Option<i64>,

}



impl cfn_resources::CfnResource for BatchRetryStrategy {
    fn type_string() -> &'static str {
        "NOT_A_VALID_CFN_RESOURCE"
    }

    fn properties(self) -> serde_json::Value {
        serde_json::to_value(self).expect("Failed to serialize cloudformation resource properties")
    }

    fn validate(&self) -> Result<(), String> {

        Ok(())
    }
}

/// The details of a capacity provider strategy. To learn more, see CapacityProviderStrategyItem in the Amazon ECS API Reference.
#[derive(Clone, Debug, Default, serde::Serialize)]
pub struct CapacityProviderStrategyItem {


    /// 
    /// The base value designates how many tasks, at a minimum, to run on the specified capacity    provider. Only one capacity provider in a capacity provider strategy can have a base defined.    If no value is specified, the default value of 0 is used.
    /// 
    /// Required: No
    ///
    /// Type: Integer
    ///
    /// Minimum: 0
    ///
    /// Maximum: 100000
    ///
    /// Update requires: No interruption
    #[serde(rename = "Base")]
    pub base: Option<i64>,


    /// 
    /// The short name of the capacity provider.
    /// 
    /// Required: Yes
    ///
    /// Type: String
    ///
    /// Minimum: 1
    ///
    /// Maximum: 255
    ///
    /// Update requires: No interruption
    #[serde(rename = "CapacityProvider")]
    pub capacity_provider: String,


    /// 
    /// The weight value designates the relative percentage of the total number of tasks launched    that should use the specified capacity provider. The weight value is taken into consideration    after the base value, if defined, is satisfied.
    /// 
    /// Required: No
    ///
    /// Type: Integer
    ///
    /// Minimum: 0
    ///
    /// Maximum: 1000
    ///
    /// Update requires: No interruption
    #[serde(rename = "Weight")]
    pub weight: Option<i64>,

}



impl cfn_resources::CfnResource for CapacityProviderStrategyItem {
    fn type_string() -> &'static str {
        "NOT_A_VALID_CFN_RESOURCE"
    }

    fn properties(self) -> serde_json::Value {
        serde_json::to_value(self).expect("Failed to serialize cloudformation resource properties")
    }

    fn validate(&self) -> Result<(), String> {

        if let Some(the_val) = &self.base {

        if *the_val > 100000 as _ {
            return Err(format!("Max validation failed on field 'base'. {} is greater than 100000", the_val));
        }

        }
        
        if let Some(the_val) = &self.base {

        if *the_val < 0 as _ {
            return Err(format!("Min validation failed on field 'base'. {} is less than 0", the_val));
        }

        }
        
        let the_val = &self.capacity_provider;

        if the_val.len() > 255 as _ {
            return Err(format!("Max validation failed on field 'capacity_provider'. {} is greater than 255", the_val.len()));
        }

        
        let the_val = &self.capacity_provider;

        if the_val.len() < 1 as _ {
            return Err(format!("Min validation failed on field 'capacity_provider'. {} is less than 1", the_val.len()));
        }

        
        if let Some(the_val) = &self.weight {

        if *the_val > 1000 as _ {
            return Err(format!("Max validation failed on field 'weight'. {} is greater than 1000", the_val));
        }

        }
        
        if let Some(the_val) = &self.weight {

        if *the_val < 0 as _ {
            return Err(format!("Min validation failed on field 'weight'. {} is less than 0", the_val));
        }

        }
        
        Ok(())
    }
}

/// A DeadLetterConfig object that contains information about a dead-letter queue    configuration.
#[derive(Clone, Debug, Default, serde::Serialize)]
pub struct DeadLetterConfig {


    /// 
    /// The ARN of the SQS queue specified as the target for the dead-letter queue.
    /// 
    /// Required: No
    ///
    /// Type: String
    ///
    /// Minimum: 1
    ///
    /// Maximum: 1600
    ///
    /// Update requires: No interruption
    #[serde(rename = "Arn")]
    pub arn: Option<String>,

}



impl cfn_resources::CfnResource for DeadLetterConfig {
    fn type_string() -> &'static str {
        "NOT_A_VALID_CFN_RESOURCE"
    }

    fn properties(self) -> serde_json::Value {
        serde_json::to_value(self).expect("Failed to serialize cloudformation resource properties")
    }

    fn validate(&self) -> Result<(), String> {

        if let Some(the_val) = &self.arn {

        if the_val.len() > 1600 as _ {
            return Err(format!("Max validation failed on field 'arn'. {} is greater than 1600", the_val.len()));
        }

        }
        
        if let Some(the_val) = &self.arn {

        if the_val.len() < 1 as _ {
            return Err(format!("Min validation failed on field 'arn'. {} is less than 1", the_val.len()));
        }

        }
        
        Ok(())
    }
}

/// The custom parameters to be used when the target is an Amazon ECS task.
#[derive(Clone, Debug, Default, serde::Serialize)]
pub struct EcsParameters {


    /// 
    /// The capacity provider strategy to use for the task.
    /// 
    /// If a capacityProviderStrategy is specified, the launchType    parameter must be omitted. If no capacityProviderStrategy or launchType is    specified, the defaultCapacityProviderStrategy for the cluster is used.
    /// 
    /// Required: No
    ///
    /// Type: List of CapacityProviderStrategyItem
    ///
    /// Maximum: 6
    ///
    /// Update requires: No interruption
    #[serde(rename = "CapacityProviderStrategy")]
    pub capacity_provider_strategy: Option<Vec<CapacityProviderStrategyItem>>,


    /// 
    /// Specifies whether to enable Amazon ECS managed tags for the task. For more information,    see Tagging Your Amazon ECS Resources in the Amazon Elastic Container Service Developer    Guide.
    /// 
    /// Required: No
    ///
    /// Type: Boolean
    ///
    /// Update requires: No interruption
    #[serde(rename = "EnableECSManagedTags")]
    pub enable_ecsmanaged_tags: Option<bool>,


    /// 
    /// Whether or not to enable the execute command functionality for the containers in this    task. If true, this enables execute command functionality on all containers in the    task.
    /// 
    /// Required: No
    ///
    /// Type: Boolean
    ///
    /// Update requires: No interruption
    #[serde(rename = "EnableExecuteCommand")]
    pub enable_execute_command: Option<bool>,


    /// 
    /// Specifies an ECS task group for the task. The maximum length is 255 characters.
    /// 
    /// Required: No
    ///
    /// Type: String
    ///
    /// Update requires: No interruption
    #[serde(rename = "Group")]
    pub group: Option<String>,


    /// 
    /// Specifies the launch type on which your task is running. The launch type that you specify    here must match one of the launch type (compatibilities) of the target task. The    FARGATE value is supported only in the Regions where AWS Fargate with Amazon ECS   is supported. For more information, see AWS Fargate on Amazon ECS in    the Amazon Elastic Container Service Developer Guide.
    /// 
    /// Required: No
    ///
    /// Type: String
    ///
    /// Allowed values: EC2 | EXTERNAL | FARGATE
    ///
    /// Update requires: No interruption
    #[serde(rename = "LaunchType")]
    pub launch_type: Option<EcsParametersLaunchTypeEnum>,


    /// 
    /// Use this structure if the Amazon ECS task uses the awsvpc network mode. This    structure specifies the VPC subnets and security groups associated with the task, and whether    a public IP address is to be used. This structure is required if LaunchType is     FARGATE because the awsvpc mode is required for Fargate    tasks.
    /// 
    /// If you specify NetworkConfiguration when the target ECS task does not use the     awsvpc network mode, the task fails.
    /// 
    /// Required: No
    ///
    /// Type: NetworkConfiguration
    ///
    /// Update requires: No interruption
    #[serde(rename = "NetworkConfiguration")]
    pub network_configuration: Option<NetworkConfiguration>,


    /// 
    /// An array of placement constraint objects to use for the task. You can specify up to 10    constraints per task (including constraints in the task definition and those specified at    runtime).
    /// 
    /// Required: No
    ///
    /// Type: List of PlacementConstraint
    ///
    /// Maximum: 10
    ///
    /// Update requires: No interruption
    #[serde(rename = "PlacementConstraints")]
    pub placement_constraints: Option<Vec<PlacementConstraint>>,


    /// 
    /// The placement strategy objects to use for the task. You can specify a maximum of five    strategy rules per task.
    /// 
    /// Required: No
    ///
    /// Type: List of PlacementStrategy
    ///
    /// Maximum: 5
    ///
    /// Update requires: No interruption
    #[serde(rename = "PlacementStrategies")]
    pub placement_strategies: Option<Vec<PlacementStrategy>>,


    /// 
    /// Specifies the platform version for the task. Specify only the numeric portion of the    platform version, such as 1.1.0.
    /// 
    /// This structure is used only if LaunchType is FARGATE. For more    information about valid platform versions, see AWS Fargate Platform     Versions in the Amazon Elastic Container Service Developer     Guide.
    /// 
    /// Required: No
    ///
    /// Type: String
    ///
    /// Update requires: No interruption
    #[serde(rename = "PlatformVersion")]
    pub platform_version: Option<String>,


    /// 
    /// Specifies whether to propagate the tags from the task definition to the task. If no value    is specified, the tags are not propagated. Tags can only be propagated to the task during task    creation. To add tags to a task after task creation, use the TagResource API action.
    /// 
    /// Required: No
    ///
    /// Type: String
    ///
    /// Allowed values: TASK_DEFINITION
    ///
    /// Update requires: No interruption
    #[serde(rename = "PropagateTags")]
    pub propagate_tags: Option<EcsParametersPropagateTagsEnum>,


    /// 
    /// The reference ID to use for the task.
    /// 
    /// Required: No
    ///
    /// Type: String
    ///
    /// Maximum: 1024
    ///
    /// Update requires: No interruption
    #[serde(rename = "ReferenceId")]
    pub reference_id: Option<String>,


    /// 
    /// The metadata that you apply to the task to help you categorize and organize them. Each tag    consists of a key and an optional value, both of which you define. To learn more, see RunTask in the Amazon ECS API Reference.
    /// 
    /// Required: No
    ///
    /// Type: List of Tag
    ///
    /// Update requires: No interruption
    #[serde(rename = "TagList")]
    pub tag_list: Option<Vec<Tag>>,


    /// 
    /// The number of tasks to create based on TaskDefinition. The default is    1.
    /// 
    /// Required: No
    ///
    /// Type: Integer
    ///
    /// Minimum: 1
    ///
    /// Update requires: No interruption
    #[serde(rename = "TaskCount")]
    pub task_count: Option<i64>,


    /// 
    /// The ARN of the task definition to use if the event target is an Amazon ECS task.
    /// 
    /// Required: Yes
    ///
    /// Type: String
    ///
    /// Minimum: 1
    ///
    /// Maximum: 1600
    ///
    /// Update requires: No interruption
    #[serde(rename = "TaskDefinitionArn")]
    pub task_definition_arn: String,

}


#[derive(Clone, Debug, serde::Serialize)]
pub enum EcsParametersLaunchTypeEnum {

    /// EC2
    #[serde(rename = "EC2")]
    Ec2,

    /// EXTERNAL
    #[serde(rename = "EXTERNAL")]
    External,

    /// FARGATE
    #[serde(rename = "FARGATE")]
    Fargate,

}

impl Default for EcsParametersLaunchTypeEnum {
    fn default() -> Self {
        EcsParametersLaunchTypeEnum::Ec2
    }
}

#[derive(Clone, Debug, serde::Serialize)]
pub enum EcsParametersPropagateTagsEnum {

    /// TASK_DEFINITION
    #[serde(rename = "TASK_DEFINITION")]
    Taskdefinition,

}

impl Default for EcsParametersPropagateTagsEnum {
    fn default() -> Self {
        EcsParametersPropagateTagsEnum::Taskdefinition
    }
}


impl cfn_resources::CfnResource for EcsParameters {
    fn type_string() -> &'static str {
        "NOT_A_VALID_CFN_RESOURCE"
    }

    fn properties(self) -> serde_json::Value {
        serde_json::to_value(self).expect("Failed to serialize cloudformation resource properties")
    }

    fn validate(&self) -> Result<(), String> {

        if let Some(the_val) = &self.capacity_provider_strategy {

        if the_val.len() > 6 as _ {
            return Err(format!("Max validation failed on field 'capacity_provider_strategy'. {} is greater than 6", the_val.len()));
        }

        }
        
        self.network_configuration.as_ref().map_or(Ok(()), |val| val.validate())?;

        if let Some(the_val) = &self.placement_constraints {

        if the_val.len() > 10 as _ {
            return Err(format!("Max validation failed on field 'placement_constraints'. {} is greater than 10", the_val.len()));
        }

        }
        
        if let Some(the_val) = &self.placement_strategies {

        if the_val.len() > 5 as _ {
            return Err(format!("Max validation failed on field 'placement_strategies'. {} is greater than 5", the_val.len()));
        }

        }
        
        if let Some(the_val) = &self.reference_id {

        if the_val.len() > 1024 as _ {
            return Err(format!("Max validation failed on field 'reference_id'. {} is greater than 1024", the_val.len()));
        }

        }
        
        if let Some(the_val) = &self.task_count {

        if *the_val < 1 as _ {
            return Err(format!("Min validation failed on field 'task_count'. {} is less than 1", the_val));
        }

        }
        
        let the_val = &self.task_definition_arn;

        if the_val.len() > 1600 as _ {
            return Err(format!("Max validation failed on field 'task_definition_arn'. {} is greater than 1600", the_val.len()));
        }

        
        let the_val = &self.task_definition_arn;

        if the_val.len() < 1 as _ {
            return Err(format!("Min validation failed on field 'task_definition_arn'. {} is less than 1", the_val.len()));
        }

        
        Ok(())
    }
}

/// These are custom parameter to be used when the target is an API Gateway APIs or    EventBridge ApiDestinations. In the latter case, these are merged with any    InvocationParameters specified on the Connection, with any values from the Connection taking    precedence.
#[derive(Clone, Debug, Default, serde::Serialize)]
pub struct HttpParameters {


    /// 
    /// The headers that need to be sent as part of request invoking the API Gateway API or    EventBridge ApiDestination.
    /// 
    /// Required: No
    ///
    /// Type: Map of String
    ///
    /// Update requires: No interruption
    #[serde(rename = "HeaderParameters")]
    pub header_parameters: Option<std::collections::HashMap<String, String>>,


    /// 
    /// The path parameter values to be used to populate API Gateway API or EventBridge    ApiDestination path wildcards ("*").
    /// 
    /// Required: No
    ///
    /// Type: List of String
    ///
    /// Update requires: No interruption
    #[serde(rename = "PathParameterValues")]
    pub path_parameter_values: Option<Vec<String>>,


    /// 
    /// The query string keys/values that need to be sent as part of request invoking the API Gateway    API or EventBridge ApiDestination.
    /// 
    /// Required: No
    ///
    /// Type: Map of String
    ///
    /// Update requires: No interruption
    #[serde(rename = "QueryStringParameters")]
    pub query_string_parameters: Option<std::collections::HashMap<String, String>>,

}



impl cfn_resources::CfnResource for HttpParameters {
    fn type_string() -> &'static str {
        "NOT_A_VALID_CFN_RESOURCE"
    }

    fn properties(self) -> serde_json::Value {
        serde_json::to_value(self).expect("Failed to serialize cloudformation resource properties")
    }

    fn validate(&self) -> Result<(), String> {

        Ok(())
    }
}

/// Contains the parameters needed for you to provide custom input to a target based on one or    more pieces of data extracted from the event.
#[derive(Clone, Debug, Default, serde::Serialize)]
pub struct InputTransformer {


    /// 
    /// Map of JSON paths to be extracted from the event. You can then insert these in the    template in InputTemplate to produce the output you want to be sent to the    target.
    /// 
    /// InputPathsMap is an array key-value pairs, where each value is a valid JSON    path. You can have as many as 100 key-value pairs. You must use JSON dot notation, not bracket    notation.
    /// 
    /// The keys cannot start with "AWS."
    /// 
    /// Required: No
    ///
    /// Type: Map of String
    ///
    /// Update requires: No interruption
    #[serde(rename = "InputPathsMap")]
    pub input_paths_map: Option<std::collections::HashMap<String, String>>,


    /// 
    /// Input template where you specify placeholders that will be filled with the values of the    keys from InputPathsMap to customize the data sent to the target. Enclose each     InputPathsMaps value in brackets: <value>
    /// 
    /// If InputTemplate is a JSON object (surrounded by curly braces), the following    restrictions apply:
    /// 
    /// The placeholder cannot be used as an object key.
    /// 
    /// The following example shows the syntax for using InputPathsMap and     InputTemplate.
    /// 
    /// "InputTransformer":
    /// 
    /// {
    /// 
    /// "InputPathsMap": {"instance": "$.detail.instance","status":     "$.detail.status"},
    /// 
    /// "InputTemplate": "<instance> is in state <status>"
    /// 
    /// }
    /// 
    /// To have the InputTemplate include quote marks within a JSON string, escape    each quote marks with a slash, as in the following example:
    /// 
    /// "InputTransformer":
    /// 
    /// {
    /// 
    /// "InputPathsMap": {"instance": "$.detail.instance","status":     "$.detail.status"},
    /// 
    /// "InputTemplate": "<instance> is in state \"<status>\""
    /// 
    /// }
    /// 
    /// The InputTemplate can also be valid JSON with varibles in quotes or out, as    in the following example:
    /// 
    /// "InputTransformer":
    /// 
    /// {
    /// 
    /// "InputPathsMap": {"instance": "$.detail.instance","status":     "$.detail.status"},
    /// 
    /// "InputTemplate": '{"myInstance": <instance>,"myStatus": "<instance> is     in state \"<status>\""}'
    /// 
    /// }
    /// 
    /// Required: Yes
    ///
    /// Type: String
    ///
    /// Minimum: 1
    ///
    /// Maximum: 8192
    ///
    /// Update requires: No interruption
    #[serde(rename = "InputTemplate")]
    pub input_template: String,

}



impl cfn_resources::CfnResource for InputTransformer {
    fn type_string() -> &'static str {
        "NOT_A_VALID_CFN_RESOURCE"
    }

    fn properties(self) -> serde_json::Value {
        serde_json::to_value(self).expect("Failed to serialize cloudformation resource properties")
    }

    fn validate(&self) -> Result<(), String> {

        let the_val = &self.input_template;

        if the_val.len() > 8192 as _ {
            return Err(format!("Max validation failed on field 'input_template'. {} is greater than 8192", the_val.len()));
        }

        
        let the_val = &self.input_template;

        if the_val.len() < 1 as _ {
            return Err(format!("Min validation failed on field 'input_template'. {} is less than 1", the_val.len()));
        }

        
        Ok(())
    }
}

/// This object enables you to specify a JSON path to extract from the event and use as the    partition key for the Amazon Kinesis data stream, so that you can control the shard to which    the event goes. If you do not include this parameter, the default is to use the     eventId as the partition key.
#[derive(Clone, Debug, Default, serde::Serialize)]
pub struct KinesisParameters {


    /// 
    /// The JSON path to be extracted from the event and used as the partition key. For more    information, see Amazon Kinesis Streams Key     Concepts in the Amazon Kinesis Streams Developer Guide.
    /// 
    /// Required: Yes
    ///
    /// Type: String
    ///
    /// Maximum: 256
    ///
    /// Update requires: No interruption
    #[serde(rename = "PartitionKeyPath")]
    pub partition_key_path: String,

}



impl cfn_resources::CfnResource for KinesisParameters {
    fn type_string() -> &'static str {
        "NOT_A_VALID_CFN_RESOURCE"
    }

    fn properties(self) -> serde_json::Value {
        serde_json::to_value(self).expect("Failed to serialize cloudformation resource properties")
    }

    fn validate(&self) -> Result<(), String> {

        let the_val = &self.partition_key_path;

        if the_val.len() > 256 as _ {
            return Err(format!("Max validation failed on field 'partition_key_path'. {} is greater than 256", the_val.len()));
        }

        
        Ok(())
    }
}

/// This structure specifies the network configuration for an ECS task.
#[derive(Clone, Debug, Default, serde::Serialize)]
pub struct NetworkConfiguration {


    /// 
    /// Use this structure to specify the VPC subnets and security groups for the task, and    whether a public IP address is to be used. This structure is relevant only for ECS tasks that    use the awsvpc network mode.
    /// 
    /// Required: No
    ///
    /// Type: AwsVpcConfiguration
    ///
    /// Update requires: No interruption
    #[serde(rename = "AwsVpcConfiguration")]
    pub aws_vpc_configuration: Option<AwsVpcConfiguration>,

}



impl cfn_resources::CfnResource for NetworkConfiguration {
    fn type_string() -> &'static str {
        "NOT_A_VALID_CFN_RESOURCE"
    }

    fn properties(self) -> serde_json::Value {
        serde_json::to_value(self).expect("Failed to serialize cloudformation resource properties")
    }

    fn validate(&self) -> Result<(), String> {

        self.aws_vpc_configuration.as_ref().map_or(Ok(()), |val| val.validate())?;

        Ok(())
    }
}

/// An object representing a constraint on task placement. To learn more, see Task Placement Constraints in the Amazon Elastic Container Service Developer    Guide.
#[derive(Clone, Debug, Default, serde::Serialize)]
pub struct PlacementConstraint {


    /// 
    /// A cluster query language expression to apply to the constraint. You cannot specify an    expression if the constraint type is distinctInstance. To learn more, see Cluster Query Language in the Amazon Elastic Container Service Developer Guide.
    /// 
    /// Required: No
    ///
    /// Type: String
    ///
    /// Maximum: 2000
    ///
    /// Update requires: No interruption
    #[serde(rename = "Expression")]
    pub expression: Option<String>,


    /// 
    /// The type of constraint. Use distinctInstance to ensure that each task in a particular    group is running on a different container instance. Use memberOf to restrict the selection to    a group of valid candidates.
    /// 
    /// Required: No
    ///
    /// Type: String
    ///
    /// Allowed values: distinctInstance | memberOf
    ///
    /// Update requires: No interruption
    #[serde(rename = "Type")]
    pub cfn_type: Option<PlacementConstraintTypeEnum>,

}


#[derive(Clone, Debug, serde::Serialize)]
pub enum PlacementConstraintTypeEnum {

    /// distinctInstance
    #[serde(rename = "distinctInstance")]
    Distinctinstance,

    /// memberOf
    #[serde(rename = "memberOf")]
    Memberof,

}

impl Default for PlacementConstraintTypeEnum {
    fn default() -> Self {
        PlacementConstraintTypeEnum::Distinctinstance
    }
}


impl cfn_resources::CfnResource for PlacementConstraint {
    fn type_string() -> &'static str {
        "NOT_A_VALID_CFN_RESOURCE"
    }

    fn properties(self) -> serde_json::Value {
        serde_json::to_value(self).expect("Failed to serialize cloudformation resource properties")
    }

    fn validate(&self) -> Result<(), String> {

        if let Some(the_val) = &self.expression {

        if the_val.len() > 2000 as _ {
            return Err(format!("Max validation failed on field 'expression'. {} is greater than 2000", the_val.len()));
        }

        }
        
        Ok(())
    }
}

/// The task placement strategy for a task or service. To learn more, see Task Placement Strategies in the Amazon Elastic Container Service Service Developer    Guide.
#[derive(Clone, Debug, Default, serde::Serialize)]
pub struct PlacementStrategy {


    /// 
    /// The field to apply the placement strategy against. For the spread placement strategy,    valid values are instanceId (or host, which has the same effect), or any platform or custom    attribute that is applied to a container instance, such as attribute:ecs.availability-zone.    For the binpack placement strategy, valid values are cpu and memory. For the random placement    strategy, this field is not used.
    /// 
    /// Required: No
    ///
    /// Type: String
    ///
    /// Maximum: 255
    ///
    /// Update requires: No interruption
    #[serde(rename = "Field")]
    pub field: Option<String>,


    /// 
    /// The type of placement strategy. The random placement strategy randomly places tasks on    available candidates. The spread placement strategy spreads placement across available    candidates evenly based on the field parameter. The binpack strategy places tasks on available    candidates that have the least available amount of the resource that is specified with the    field parameter. For example, if you binpack on memory, a task is placed on the instance with    the least amount of remaining memory (but still enough to run the task).
    /// 
    /// Required: No
    ///
    /// Type: String
    ///
    /// Allowed values: binpack | random | spread
    ///
    /// Update requires: No interruption
    #[serde(rename = "Type")]
    pub cfn_type: Option<PlacementStrategyTypeEnum>,

}


#[derive(Clone, Debug, serde::Serialize)]
pub enum PlacementStrategyTypeEnum {

    /// binpack
    #[serde(rename = "binpack")]
    Binpack,

    /// random
    #[serde(rename = "random")]
    Random,

    /// spread
    #[serde(rename = "spread")]
    Spread,

}

impl Default for PlacementStrategyTypeEnum {
    fn default() -> Self {
        PlacementStrategyTypeEnum::Binpack
    }
}


impl cfn_resources::CfnResource for PlacementStrategy {
    fn type_string() -> &'static str {
        "NOT_A_VALID_CFN_RESOURCE"
    }

    fn properties(self) -> serde_json::Value {
        serde_json::to_value(self).expect("Failed to serialize cloudformation resource properties")
    }

    fn validate(&self) -> Result<(), String> {

        if let Some(the_val) = &self.field {

        if the_val.len() > 255 as _ {
            return Err(format!("Max validation failed on field 'field'. {} is greater than 255", the_val.len()));
        }

        }
        
        Ok(())
    }
}

/// These are custom parameters to be used when the target is a Amazon Redshift cluster to invoke the    Amazon Redshift Data API ExecuteStatement based on EventBridge events.
#[derive(Clone, Debug, Default, serde::Serialize)]
pub struct RedshiftDataParameters {


    /// 
    /// The name of the database. Required when authenticating using temporary credentials.
    /// 
    /// Required: Yes
    ///
    /// Type: String
    ///
    /// Minimum: 1
    ///
    /// Maximum: 64
    ///
    /// Update requires: No interruption
    #[serde(rename = "Database")]
    pub database: String,


    /// 
    /// The database user name. Required when authenticating using temporary credentials.
    /// 
    /// Required: No
    ///
    /// Type: String
    ///
    /// Minimum: 1
    ///
    /// Maximum: 128
    ///
    /// Update requires: No interruption
    #[serde(rename = "DbUser")]
    pub db_user: Option<String>,


    /// 
    /// The name or ARN of the secret that enables access to the database. Required when    authenticating using AWS Secrets Manager.
    /// 
    /// Required: No
    ///
    /// Type: String
    ///
    /// Minimum: 1
    ///
    /// Maximum: 1600
    ///
    /// Pattern: (^arn:aws([a-z]|\-)*:secretsmanager:[a-z0-9-.]+:.*)|(\$(\.[\w_-]+(\[(\d+|\*)\])*)*)
    ///
    /// Update requires: No interruption
    #[serde(rename = "SecretManagerArn")]
    pub secret_manager_arn: Option<String>,


    /// 
    /// The SQL statement text to run.
    /// 
    /// Required: Yes
    ///
    /// Type: String
    ///
    /// Minimum: 1
    ///
    /// Maximum: 100000
    ///
    /// Update requires: No interruption
    #[serde(rename = "Sql")]
    pub sql: String,


    /// 
    /// The name of the SQL statement. You can name the SQL statement when you create it to    identify the query.
    /// 
    /// Required: No
    ///
    /// Type: String
    ///
    /// Minimum: 1
    ///
    /// Maximum: 500
    ///
    /// Update requires: No interruption
    #[serde(rename = "StatementName")]
    pub statement_name: Option<String>,


    /// 
    /// Indicates whether to send an event back to EventBridge after the SQL statement    runs.
    /// 
    /// Required: No
    ///
    /// Type: Boolean
    ///
    /// Update requires: No interruption
    #[serde(rename = "WithEvent")]
    pub with_event: Option<bool>,

}



impl cfn_resources::CfnResource for RedshiftDataParameters {
    fn type_string() -> &'static str {
        "NOT_A_VALID_CFN_RESOURCE"
    }

    fn properties(self) -> serde_json::Value {
        serde_json::to_value(self).expect("Failed to serialize cloudformation resource properties")
    }

    fn validate(&self) -> Result<(), String> {

        let the_val = &self.database;

        if the_val.len() > 64 as _ {
            return Err(format!("Max validation failed on field 'database'. {} is greater than 64", the_val.len()));
        }

        
        let the_val = &self.database;

        if the_val.len() < 1 as _ {
            return Err(format!("Min validation failed on field 'database'. {} is less than 1", the_val.len()));
        }

        
        if let Some(the_val) = &self.db_user {

        if the_val.len() > 128 as _ {
            return Err(format!("Max validation failed on field 'db_user'. {} is greater than 128", the_val.len()));
        }

        }
        
        if let Some(the_val) = &self.db_user {

        if the_val.len() < 1 as _ {
            return Err(format!("Min validation failed on field 'db_user'. {} is less than 1", the_val.len()));
        }

        }
        
        if let Some(the_val) = &self.secret_manager_arn {

        if the_val.len() > 1600 as _ {
            return Err(format!("Max validation failed on field 'secret_manager_arn'. {} is greater than 1600", the_val.len()));
        }

        }
        
        if let Some(the_val) = &self.secret_manager_arn {

        if the_val.len() < 1 as _ {
            return Err(format!("Min validation failed on field 'secret_manager_arn'. {} is less than 1", the_val.len()));
        }

        }
        
        let the_val = &self.sql;

        if the_val.len() > 100000 as _ {
            return Err(format!("Max validation failed on field 'sql'. {} is greater than 100000", the_val.len()));
        }

        
        let the_val = &self.sql;

        if the_val.len() < 1 as _ {
            return Err(format!("Min validation failed on field 'sql'. {} is less than 1", the_val.len()));
        }

        
        if let Some(the_val) = &self.statement_name {

        if the_val.len() > 500 as _ {
            return Err(format!("Max validation failed on field 'statement_name'. {} is greater than 500", the_val.len()));
        }

        }
        
        if let Some(the_val) = &self.statement_name {

        if the_val.len() < 1 as _ {
            return Err(format!("Min validation failed on field 'statement_name'. {} is less than 1", the_val.len()));
        }

        }
        
        Ok(())
    }
}

/// A RetryPolicy object that includes information about the retry policy    settings.
#[derive(Clone, Debug, Default, serde::Serialize)]
pub struct RetryPolicy {


    /// 
    /// The maximum amount of time, in seconds, to continue to make retry attempts.
    /// 
    /// Required: No
    ///
    /// Type: Integer
    ///
    /// Minimum: 60
    ///
    /// Maximum: 86400
    ///
    /// Update requires: No interruption
    #[serde(rename = "MaximumEventAgeInSeconds")]
    pub maximum_event_age_in_seconds: Option<i64>,


    /// 
    /// The maximum number of retry attempts to make before the request fails. Retry attempts    continue until either the maximum number of attempts is made or until the duration of the     MaximumEventAgeInSeconds is met.
    /// 
    /// Required: No
    ///
    /// Type: Integer
    ///
    /// Minimum: 0
    ///
    /// Maximum: 185
    ///
    /// Update requires: No interruption
    #[serde(rename = "MaximumRetryAttempts")]
    pub maximum_retry_attempts: Option<i64>,

}



impl cfn_resources::CfnResource for RetryPolicy {
    fn type_string() -> &'static str {
        "NOT_A_VALID_CFN_RESOURCE"
    }

    fn properties(self) -> serde_json::Value {
        serde_json::to_value(self).expect("Failed to serialize cloudformation resource properties")
    }

    fn validate(&self) -> Result<(), String> {

        if let Some(the_val) = &self.maximum_event_age_in_seconds {

        if *the_val > 86400 as _ {
            return Err(format!("Max validation failed on field 'maximum_event_age_in_seconds'. {} is greater than 86400", the_val));
        }

        }
        
        if let Some(the_val) = &self.maximum_event_age_in_seconds {

        if *the_val < 60 as _ {
            return Err(format!("Min validation failed on field 'maximum_event_age_in_seconds'. {} is less than 60", the_val));
        }

        }
        
        if let Some(the_val) = &self.maximum_retry_attempts {

        if *the_val > 185 as _ {
            return Err(format!("Max validation failed on field 'maximum_retry_attempts'. {} is greater than 185", the_val));
        }

        }
        
        if let Some(the_val) = &self.maximum_retry_attempts {

        if *the_val < 0 as _ {
            return Err(format!("Min validation failed on field 'maximum_retry_attempts'. {} is less than 0", the_val));
        }

        }
        
        Ok(())
    }
}

/// This parameter contains the criteria (either InstanceIds or a tag) used to specify which    EC2 instances are to be sent the command.
#[derive(Clone, Debug, Default, serde::Serialize)]
pub struct RunCommandParameters {


    /// 
    /// Currently, we support including only one RunCommandTarget block, which specifies either an    array of InstanceIds or a tag.
    /// 
    /// Required: Yes
    ///
    /// Type: List of RunCommandTarget
    ///
    /// Maximum: 5
    ///
    /// Update requires: No interruption
    #[serde(rename = "RunCommandTargets")]
    pub run_command_targets: Vec<RunCommandTarget>,

}



impl cfn_resources::CfnResource for RunCommandParameters {
    fn type_string() -> &'static str {
        "NOT_A_VALID_CFN_RESOURCE"
    }

    fn properties(self) -> serde_json::Value {
        serde_json::to_value(self).expect("Failed to serialize cloudformation resource properties")
    }

    fn validate(&self) -> Result<(), String> {

        let the_val = &self.run_command_targets;

        if the_val.len() > 5 as _ {
            return Err(format!("Max validation failed on field 'run_command_targets'. {} is greater than 5", the_val.len()));
        }

        
        Ok(())
    }
}

/// Information about the EC2 instances that are to be sent the command, specified as    key-value pairs. Each RunCommandTarget block can include only one key, but this    key may specify multiple values.
#[derive(Clone, Debug, Default, serde::Serialize)]
pub struct RunCommandTarget {


    /// 
    /// Can be either tag:       tag-key or    InstanceIds.
    /// 
    /// Required: Yes
    ///
    /// Type: String
    ///
    /// Minimum: 1
    ///
    /// Maximum: 128
    ///
    /// Pattern: ^[\p{L}\p{Z}\p{N}_.:/=+\-@]*$
    ///
    /// Update requires: No interruption
    #[serde(rename = "Key")]
    pub key: String,


    /// 
    /// If Key is tag:       tag-key, Values    is a list of tag values. If Key is InstanceIds, Values    is a list of Amazon EC2 instance IDs.
    /// 
    /// Required: Yes
    ///
    /// Type: List of String
    ///
    /// Maximum: 50
    ///
    /// Update requires: No interruption
    #[serde(rename = "Values")]
    pub values: Vec<String>,

}



impl cfn_resources::CfnResource for RunCommandTarget {
    fn type_string() -> &'static str {
        "NOT_A_VALID_CFN_RESOURCE"
    }

    fn properties(self) -> serde_json::Value {
        serde_json::to_value(self).expect("Failed to serialize cloudformation resource properties")
    }

    fn validate(&self) -> Result<(), String> {

        let the_val = &self.key;

        if the_val.len() > 128 as _ {
            return Err(format!("Max validation failed on field 'key'. {} is greater than 128", the_val.len()));
        }

        
        let the_val = &self.key;

        if the_val.len() < 1 as _ {
            return Err(format!("Min validation failed on field 'key'. {} is less than 1", the_val.len()));
        }

        
        let the_val = &self.values;

        if the_val.len() > 50 as _ {
            return Err(format!("Max validation failed on field 'values'. {} is greater than 50", the_val.len()));
        }

        
        Ok(())
    }
}

/// Name/Value pair of a parameter to start execution of a SageMaker Model Building    Pipeline.
#[derive(Clone, Debug, Default, serde::Serialize)]
pub struct SageMakerPipelineParameter {


    /// 
    /// Name of parameter to start execution of a SageMaker Model Building Pipeline.
    /// 
    /// Required: Yes
    ///
    /// Type: String
    ///
    /// Minimum: 1
    ///
    /// Maximum: 256
    ///
    /// Pattern: ^[a-zA-Z0-9](-*[a-zA-Z0-9])*$
    ///
    /// Update requires: No interruption
    #[serde(rename = "Name")]
    pub name: String,


    /// 
    /// Value of parameter to start execution of a SageMaker Model Building Pipeline.
    /// 
    /// Required: Yes
    ///
    /// Type: String
    ///
    /// Maximum: 1024
    ///
    /// Update requires: No interruption
    #[serde(rename = "Value")]
    pub value: String,

}



impl cfn_resources::CfnResource for SageMakerPipelineParameter {
    fn type_string() -> &'static str {
        "NOT_A_VALID_CFN_RESOURCE"
    }

    fn properties(self) -> serde_json::Value {
        serde_json::to_value(self).expect("Failed to serialize cloudformation resource properties")
    }

    fn validate(&self) -> Result<(), String> {

        let the_val = &self.name;

        if the_val.len() > 256 as _ {
            return Err(format!("Max validation failed on field 'name'. {} is greater than 256", the_val.len()));
        }

        
        let the_val = &self.name;

        if the_val.len() < 1 as _ {
            return Err(format!("Min validation failed on field 'name'. {} is less than 1", the_val.len()));
        }

        
        let the_val = &self.value;

        if the_val.len() > 1024 as _ {
            return Err(format!("Max validation failed on field 'value'. {} is greater than 1024", the_val.len()));
        }

        
        Ok(())
    }
}

/// These are custom parameters to use when the target is a SageMaker Model Building Pipeline    that starts based on EventBridge events.
#[derive(Clone, Debug, Default, serde::Serialize)]
pub struct SageMakerPipelineParameters {


    /// 
    /// List of Parameter names and values for SageMaker Model Building Pipeline execution.
    /// 
    /// Required: No
    ///
    /// Type: List of SageMakerPipelineParameter
    ///
    /// Maximum: 200
    ///
    /// Update requires: No interruption
    #[serde(rename = "PipelineParameterList")]
    pub pipeline_parameter_list: Option<Vec<SageMakerPipelineParameter>>,

}



impl cfn_resources::CfnResource for SageMakerPipelineParameters {
    fn type_string() -> &'static str {
        "NOT_A_VALID_CFN_RESOURCE"
    }

    fn properties(self) -> serde_json::Value {
        serde_json::to_value(self).expect("Failed to serialize cloudformation resource properties")
    }

    fn validate(&self) -> Result<(), String> {

        if let Some(the_val) = &self.pipeline_parameter_list {

        if the_val.len() > 200 as _ {
            return Err(format!("Max validation failed on field 'pipeline_parameter_list'. {} is greater than 200", the_val.len()));
        }

        }
        
        Ok(())
    }
}

/// This structure includes the custom parameter to be used when the target is an SQS FIFO    queue.
#[derive(Clone, Debug, Default, serde::Serialize)]
pub struct SqsParameters {


    /// 
    /// The FIFO message group ID to use as the target.
    /// 
    /// Required: Yes
    ///
    /// Type: String
    ///
    /// Maximum: 100
    ///
    /// Update requires: No interruption
    #[serde(rename = "MessageGroupId")]
    pub message_group_id: String,

}



impl cfn_resources::CfnResource for SqsParameters {
    fn type_string() -> &'static str {
        "NOT_A_VALID_CFN_RESOURCE"
    }

    fn properties(self) -> serde_json::Value {
        serde_json::to_value(self).expect("Failed to serialize cloudformation resource properties")
    }

    fn validate(&self) -> Result<(), String> {

        let the_val = &self.message_group_id;

        if the_val.len() > 100 as _ {
            return Err(format!("Max validation failed on field 'message_group_id'. {} is greater than 100", the_val.len()));
        }

        
        Ok(())
    }
}

/// A key-value pair associated with an ECS Target of an EventBridge rule. The tag will be propagated to ECS by EventBridge when starting    an ECS task based on a matched event.
#[derive(Clone, Debug, Default, serde::Serialize)]
pub struct Tag {


    /// 
    /// A string you can use to assign a value. The combination of tag keys and values can help    you organize and categorize your resources.
    /// 
    /// Required: No
    ///
    /// Type: String
    ///
    /// Minimum: 1
    ///
    /// Maximum: 128
    ///
    /// Update requires: No interruption
    #[serde(rename = "Key")]
    pub key: Option<String>,


    /// 
    /// The value for the specified tag key.
    /// 
    /// Required: No
    ///
    /// Type: String
    ///
    /// Minimum: 0
    ///
    /// Maximum: 256
    ///
    /// Update requires: No interruption
    #[serde(rename = "Value")]
    pub value: Option<String>,

}



impl cfn_resources::CfnResource for Tag {
    fn type_string() -> &'static str {
        "NOT_A_VALID_CFN_RESOURCE"
    }

    fn properties(self) -> serde_json::Value {
        serde_json::to_value(self).expect("Failed to serialize cloudformation resource properties")
    }

    fn validate(&self) -> Result<(), String> {

        if let Some(the_val) = &self.key {

        if the_val.len() > 128 as _ {
            return Err(format!("Max validation failed on field 'key'. {} is greater than 128", the_val.len()));
        }

        }
        
        if let Some(the_val) = &self.key {

        if the_val.len() < 1 as _ {
            return Err(format!("Min validation failed on field 'key'. {} is less than 1", the_val.len()));
        }

        }
        
        if let Some(the_val) = &self.value {

        if the_val.len() > 256 as _ {
            return Err(format!("Max validation failed on field 'value'. {} is greater than 256", the_val.len()));
        }

        }
        
        if let Some(the_val) = &self.value {

        if the_val.len() < 0 as _ {
            return Err(format!("Min validation failed on field 'value'. {} is less than 0", the_val.len()));
        }

        }
        
        Ok(())
    }
}

/// Targets are the resources to be invoked when a rule is triggered. For a complete list of    services and resources that can be set as a target, see PutTargets.
///
/// If you are setting the event bus of another account as the target, and that account    granted permission to your account through an organization instead of directly by the account    ID, then you must specify a RoleArn with proper permissions in the     Target structure. For more information, see Sending and      Receiving Events Between AWS Accounts in the Amazon EventBridge User     Guide.
#[derive(Clone, Debug, Default, serde::Serialize)]
pub struct Target {


    /// 
    /// The Amazon Resource Name (ARN) of the target.
    /// 
    /// Required: Yes
    ///
    /// Type: String
    ///
    /// Minimum: 1
    ///
    /// Maximum: 1600
    ///
    /// Update requires: No interruption
    #[serde(rename = "Arn")]
    pub arn: String,


    /// 
    /// If the event target is an AWS Batch job, this contains the job definition, job name, and    other parameters. For more information, see Jobs in the         AWS Batch User     Guide.
    /// 
    /// Required: No
    ///
    /// Type: BatchParameters
    ///
    /// Update requires: No interruption
    #[serde(rename = "BatchParameters")]
    pub batch_parameters: Option<BatchParameters>,


    /// 
    /// The DeadLetterConfig that defines the target queue to send dead-letter queue    events to.
    /// 
    /// Required: No
    ///
    /// Type: DeadLetterConfig
    ///
    /// Update requires: No interruption
    #[serde(rename = "DeadLetterConfig")]
    pub dead_letter_config: Option<DeadLetterConfig>,


    /// 
    /// Contains the Amazon ECS task definition and task count to be used, if the event target is    an Amazon ECS task. For more information about Amazon ECS tasks, see Task     Definitions in the Amazon EC2 Container Service Developer     Guide.
    /// 
    /// Required: No
    ///
    /// Type: EcsParameters
    ///
    /// Update requires: No interruption
    #[serde(rename = "EcsParameters")]
    pub ecs_parameters: Option<EcsParameters>,


    /// 
    /// Contains the HTTP parameters to use when the target is a API Gateway endpoint or    EventBridge ApiDestination.
    /// 
    /// If you specify an API Gateway API or EventBridge ApiDestination as a target, you can    use this parameter to specify headers, path parameters, and query string keys/values as part    of your target invoking request. If you're using ApiDestinations, the corresponding Connection    can also have these values configured. In case of any conflicting keys, values from the    Connection take precedence.
    /// 
    /// Required: No
    ///
    /// Type: HttpParameters
    ///
    /// Update requires: No interruption
    #[serde(rename = "HttpParameters")]
    pub http_parameters: Option<HttpParameters>,


    /// 
    /// The ID of the target within the specified rule. Use this ID to reference the target when updating the rule. We recommend using a memorable and unique string.
    /// 
    /// Required: Yes
    ///
    /// Type: String
    ///
    /// Minimum: 1
    ///
    /// Maximum: 64
    ///
    /// Pattern: [\.\-_A-Za-z0-9]+
    ///
    /// Update requires: No interruption
    #[serde(rename = "Id")]
    pub id: String,


    /// 
    /// Valid JSON text passed to the target. In this case, nothing from the event itself is    passed to the target. For more information, see The JavaScript Object Notation (JSON) Data     Interchange Format.
    /// 
    /// Required: No
    ///
    /// Type: String
    ///
    /// Maximum: 8192
    ///
    /// Update requires: No interruption
    #[serde(rename = "Input")]
    pub input: Option<String>,


    /// 
    /// The value of the JSONPath that is used for extracting part of the matched event when    passing it to the target. You may use JSON dot notation or bracket notation. For more    information about JSON paths, see JSONPath.
    /// 
    /// Required: No
    ///
    /// Type: String
    ///
    /// Maximum: 256
    ///
    /// Update requires: No interruption
    #[serde(rename = "InputPath")]
    pub input_path: Option<String>,


    /// 
    /// Settings to enable you to provide custom input to a target based on certain event data.    You can extract one or more key-value pairs from the event and then use that data to send    customized input to the target.
    /// 
    /// Required: No
    ///
    /// Type: InputTransformer
    ///
    /// Update requires: No interruption
    #[serde(rename = "InputTransformer")]
    pub input_transformer: Option<InputTransformer>,


    /// 
    /// The custom parameter you can use to control the shard assignment, when the target is a    Kinesis data stream. If you do not include this parameter, the default is to use the     eventId as the partition key.
    /// 
    /// Required: No
    ///
    /// Type: KinesisParameters
    ///
    /// Update requires: No interruption
    #[serde(rename = "KinesisParameters")]
    pub kinesis_parameters: Option<KinesisParameters>,


    /// 
    /// Contains the Amazon Redshift Data API parameters to use when the target is a Amazon Redshift    cluster.
    /// 
    /// If you specify a Amazon Redshift Cluster as a Target, you can use this to specify parameters to    invoke the Amazon Redshift Data API ExecuteStatement based on EventBridge events.
    /// 
    /// Required: No
    ///
    /// Type: RedshiftDataParameters
    ///
    /// Update requires: No interruption
    #[serde(rename = "RedshiftDataParameters")]
    pub redshift_data_parameters: Option<RedshiftDataParameters>,


    /// 
    /// The RetryPolicy object that contains the retry policy configuration to use    for the dead-letter queue.
    /// 
    /// Required: No
    ///
    /// Type: RetryPolicy
    ///
    /// Update requires: No interruption
    #[serde(rename = "RetryPolicy")]
    pub retry_policy: Option<RetryPolicy>,


    /// 
    /// The Amazon Resource Name (ARN) of the IAM role to be used for this target when the rule is    triggered. If one rule triggers multiple targets, you can use a different IAM role for each    target.
    /// 
    /// Required: Conditional
    ///
    /// Type: String
    ///
    /// Minimum: 1
    ///
    /// Maximum: 1600
    ///
    /// Update requires: No interruption
    #[serde(rename = "RoleArn")]
    pub role_arn: Option<String>,


    /// 
    /// Parameters used when you are using the rule to invoke Amazon EC2 Run Command.
    /// 
    /// Required: No
    ///
    /// Type: RunCommandParameters
    ///
    /// Update requires: No interruption
    #[serde(rename = "RunCommandParameters")]
    pub run_command_parameters: Option<RunCommandParameters>,


    /// 
    /// Contains the SageMaker Model Building Pipeline parameters to start execution of a    SageMaker Model Building Pipeline.
    /// 
    /// If you specify a SageMaker Model Building Pipeline as a target, you can use this to    specify parameters to start a pipeline execution based on EventBridge events.
    /// 
    /// Required: No
    ///
    /// Type: SageMakerPipelineParameters
    ///
    /// Update requires: No interruption
    #[serde(rename = "SageMakerPipelineParameters")]
    pub sage_maker_pipeline_parameters: Option<SageMakerPipelineParameters>,


    /// 
    /// Contains the message group ID to use when the target is a FIFO queue.
    /// 
    /// If you specify an SQS FIFO queue as a target, the queue must have content-based    deduplication enabled.
    /// 
    /// Required: No
    ///
    /// Type: SqsParameters
    ///
    /// Update requires: No interruption
    #[serde(rename = "SqsParameters")]
    pub sqs_parameters: Option<SqsParameters>,

}



impl cfn_resources::CfnResource for Target {
    fn type_string() -> &'static str {
        "NOT_A_VALID_CFN_RESOURCE"
    }

    fn properties(self) -> serde_json::Value {
        serde_json::to_value(self).expect("Failed to serialize cloudformation resource properties")
    }

    fn validate(&self) -> Result<(), String> {

        let the_val = &self.arn;

        if the_val.len() > 1600 as _ {
            return Err(format!("Max validation failed on field 'arn'. {} is greater than 1600", the_val.len()));
        }

        
        let the_val = &self.arn;

        if the_val.len() < 1 as _ {
            return Err(format!("Min validation failed on field 'arn'. {} is less than 1", the_val.len()));
        }

        
        self.batch_parameters.as_ref().map_or(Ok(()), |val| val.validate())?;

        self.dead_letter_config.as_ref().map_or(Ok(()), |val| val.validate())?;

        self.ecs_parameters.as_ref().map_or(Ok(()), |val| val.validate())?;

        self.http_parameters.as_ref().map_or(Ok(()), |val| val.validate())?;

        let the_val = &self.id;

        if the_val.len() > 64 as _ {
            return Err(format!("Max validation failed on field 'id'. {} is greater than 64", the_val.len()));
        }

        
        let the_val = &self.id;

        if the_val.len() < 1 as _ {
            return Err(format!("Min validation failed on field 'id'. {} is less than 1", the_val.len()));
        }

        
        if let Some(the_val) = &self.input {

        if the_val.len() > 8192 as _ {
            return Err(format!("Max validation failed on field 'input'. {} is greater than 8192", the_val.len()));
        }

        }
        
        if let Some(the_val) = &self.input_path {

        if the_val.len() > 256 as _ {
            return Err(format!("Max validation failed on field 'input_path'. {} is greater than 256", the_val.len()));
        }

        }
        
        self.input_transformer.as_ref().map_or(Ok(()), |val| val.validate())?;

        self.kinesis_parameters.as_ref().map_or(Ok(()), |val| val.validate())?;

        self.redshift_data_parameters.as_ref().map_or(Ok(()), |val| val.validate())?;

        self.retry_policy.as_ref().map_or(Ok(()), |val| val.validate())?;

        if let Some(the_val) = &self.role_arn {

        if the_val.len() > 1600 as _ {
            return Err(format!("Max validation failed on field 'role_arn'. {} is greater than 1600", the_val.len()));
        }

        }
        
        if let Some(the_val) = &self.role_arn {

        if the_val.len() < 1 as _ {
            return Err(format!("Min validation failed on field 'role_arn'. {} is less than 1", the_val.len()));
        }

        }
        
        self.run_command_parameters.as_ref().map_or(Ok(()), |val| val.validate())?;

        self.sage_maker_pipeline_parameters.as_ref().map_or(Ok(()), |val| val.validate())?;

        self.sqs_parameters.as_ref().map_or(Ok(()), |val| val.validate())?;

        Ok(())
    }
}